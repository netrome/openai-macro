//! A simple example demonstrating LLImp (Large Language Implementation).
//!
//! This example shows how to use the llimp macro to generate method implementations.
//! By default, it uses Ollama running locally - no API key needed!
//!
//! Quick start (Local Ollama):
//! 1. Install Ollama: https://ollama.com
//! 2. Start server: ollama serve
//! 3. Pull model: ollama pull gemma3:latest
//! 4. Set model: export LLM_MODEL=gemma3:latest (optional, this is the default)
//! 5. Run: cargo run -p calculator
//!
//! Remote Ollama server:
//! 1. Set remote host: export OLLAMA_HOST=192.168.1.100
//! 2. Run: cargo run -p calculator
//!
//! For cloud APIs, set LLM_MODEL, LLM_API_KEY and LLM_BASE_URL environment variables.

use llimp::llimp;

/// A simple trait for mathematical operations
pub trait Calculator {
    fn add(&self, a: i32, b: i32) -> i32;
    fn subtract(&self, a: i32, b: i32) -> i32;
    fn multiply(&self, a: i32, b: i32) -> i32;
    fn divide(&self, a: i32, b: i32) -> Option<i32>;
}

/// A basic calculator implementation
pub struct BasicCalculator;

#[llimp(
    prompt = "Implement basic arithmetic operations. For division, return None if dividing by zero."
)]
impl Calculator for BasicCalculator {
    fn add(&self, a: i32, b: i32) -> i32 {
        // Implementation will be generated by LLM
    }

    fn subtract(&self, a: i32, b: i32) -> i32 {
        // Implementation will be generated by LLM
    }

    fn multiply(&self, a: i32, b: i32) -> i32 {
        // Implementation will be generated by LLM
    }

    fn divide(&self, a: i32, b: i32) -> Option<i32> {
        // Implementation will be generated by LLM
    }
}

/// A trait for string operations
pub trait TextProcessor {
    fn uppercase(&self, text: &str) -> String;
    fn count_words(&self, text: &str) -> usize;
    fn reverse(&self, text: &str) -> String;
}

/// A text processor implementation
pub struct SimpleTextProcessor;

#[llimp(prompt = "Implement string processing functions using standard library only")]
impl TextProcessor for SimpleTextProcessor {
    fn uppercase(&self, text: &str) -> String {
        // Implementation will be generated by LLM
    }

    fn count_words(&self, text: &str) -> usize {
        // Implementation will be generated by LLM
    }

    fn reverse(&self, text: &str) -> String {
        // Implementation will be generated by LLM
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculator() {
        let calc = BasicCalculator;

        // These will only pass if the AI generates correct implementations
        assert_eq!(calc.add(2, 3), 5);
        assert_eq!(calc.subtract(10, 4), 6);
        assert_eq!(calc.multiply(3, 4), 12);
        assert_eq!(calc.divide(8, 2), Some(4));
        assert_eq!(calc.divide(5, 0), None);
    }

    #[test]
    fn test_text_processor() {
        let processor = SimpleTextProcessor;
        let text = "hello world";

        assert_eq!(processor.uppercase(text), "HELLO WORLD");
        assert_eq!(processor.count_words(text), 2);
        assert_eq!(processor.reverse(text), "dlrow olleh");
    }
}
